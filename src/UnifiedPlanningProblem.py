import unified_planning as up
from unified_planning.shortcuts import *
import numpy as np


class UnifiedPlanningProblem:
    def __init__(
        self,
        horizon: int,
        nb_gens: int,
        nb_storages: int,
        ptdf: list[list],
        mapping: dict,
        grid_params: dict,
        init_states: dict,
    ):
        self.horizon = horizon
        self.nb_gens = nb_gens
        self.nb_storages = nb_storages
        self.ptdf = ptdf
        self.mapping = mapping
        self.nb_buses = ptdf.shape[1]
        self.grid_params = grid_params
        self.init_states = init_states

        self._create_fluents()
        self._create_actions()

    def _create_fluents(self):
        # Creating problem 'variables' so called fluents in PDDL
        self.pgen = [
            [Fluent(f"pgen_{gen_id}_{t}", IntType()) for t in range(self.horizon)]
            for gen_id in range(self.nb_gens)
        ]  # active power generated by generator i at time t

        self.soc = [
            [Fluent(f"soc_{storage_id}_{t}", RealType()) for t in range(self.horizon)]
            for storage_id in range(self.nb_storages)
        ]  # state of charge of storage i at time t

        self.congestions = [
            [
                [
                    Fluent(f"congestion_{i}_{j}_{t}", BoolType())
                    for t in range(self.horizon)
                ]
                for j in range(self.nb_buses)
                if j != i
            ]
            for i in range(self.nb_buses)
        ]  # congestion between bus i and bus j at time t

        self.flows = [
            [
                [Fluent(f"flow_{i}_{j}_{t}", RealType()) for t in range(self.horizon)]
                for j in range(self.nb_buses)
                if j != i
            ]
            for i in range(self.nb_buses)
        ]  # flow between bus i and bus j at time t

    def _create_actions(self):
        self.actions_costs = {}

        # Creating actions
        self.produce = []
        for gen_id in range(self.nb_gens):
            if self.grid_params["gens"]["redispatchable"][gen_id] == True:
                pmax = self.grid_params["gens"]["pmax"][gen_id]
                pmin = self.grid_params["gens"]["pmin"][gen_id]
                delta = int(pmax - pmin)
                for t in range(self.horizon):
                    for i in range(delta):
                        self.produce[gen_id][t] = InstantaneousAction(
                            f"produce_{gen_id}_{t}_{i}", i
                        )
                        # add the opposite action

        self.charge = []
        for storage_id in range(self.nb_storages):
            emax = self.grid_params["storages"]["Emax"][storage_id]
            emin = self.grid_params["storages"]["Emin"][storage_id]

            delta = int(emax - emin)
            for t in range(self.horizon):
                for i in np.linspace(0, delta, delta * 10):
                    self.charge[storage_id][t] = InstantaneousAction(
                        f"charge_{storage_id}_{t}_{i}", round(i, 2)
                    )

        # add parameters, preconditions and effects to actions
        for gen_id in range(self.nb_gens):
            for t in range(self.horizon):
                p = self.produce[gen_id][t]
                if p > 0:
                    self.actions_costs[self.produce[gen_id][t]] = (
                        p * self.grid_params["gens"]["gen_cost_per_MW"][gen_id]
                    )
                else:
                    self.actions_costs[self.produce[gen_id][t]] = 0
                self.produce[gen_id][t].add_precondition(
                    GE(
                        self.pgen[gen_id][t],
                        p - self.grid_params["gens"]["max_ramp_up"][gen_id],
                    )
                )
                self.produce[gen_id][t].add_precondition(
                    LE(
                        self.pgen[gen_id][t],
                        p + self.grid_params["gens"]["max_ramp_down"][gen_id],
                    )
                )
                self.produce[gen_id][t].add_effect(self.pgen[gen_id][t + 1], p)
                # implement the effect on the flow + congestion var

        for storage_id in range(self.nb_storages):
            for t in range(self.horizon):
                s = self.charge[storage_id][t]
                self.actions_costs[self.charge[storage_id][t]] = 0
                self.charge[storage_id][t].add_precondition(
                    GE(
                        self.soc[storage_id][t],
                        s - self.grid_params["storages"]["Emax"][storage_id],
                    )
                )
                self.charge[storage_id][t].add_precondition(
                    LE(
                        self.soc[storage_id][t],
                        s + self.grid_params["storages"]["Emin"][storage_id],
                    )
                )
                self.charge[storage_id][t].add_effect(self.soc[storage_id][t + 1], s)
                # implement the effect on the flow + congestion var

    def create_problem(self):
        problem = Problem("GridStability")

        problem.add_fluents(self.pgen)
        problem.add_fluents(self.soc)
        problem.add_fluents(self.congestions)
        problem.add_fluents(self.flows)

        problem.add_actions(self.produce)
        problem.add_actions(self.charge)

        # add initial states
        for gen_id in range(self.nb_gens):
            problem.set_initial_value(
                self.pgen[gen_id][0], self.init_states["gens"][gen_id]
            )

        for storage_id in range(self.nb_storages):
            problem.set_initial_value(
                self.soc[storage_id][0], self.init_states["storages"][storage_id]
            )

        for i in range(self.nb_buses):
            for j in range(self.nb_buses):
                if j != i:
                    problem.set_initial_value(self.congestions[i][j][0], False)
                    problem.set_initial_value(
                        self.flows[i][j][0], self.init_states["flows"][i][j]
                    )

        problem.add_quality_metric(
            up.model.metrics.MinimizeActionCosts(self.actions_costs)
        )

        goal = And(
            [
                [
                    [self.congestions[i][j][t] for i in range(self.nb_buses)]
                    for j in range(self.nb_buses)
                    if j != i
                ]
                for t in range(self.horizon)
            ]
        )
        problem.add_goal(goal)

        self.problem = problem
        return problem
