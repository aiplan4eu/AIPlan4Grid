from unified_planning.shortcuts import *


class UnifiedPlanningProblem:
    def __init__(
        self,
        horizon: int,
        nb_gens: int,
        nb_storages: int,
        ptdf: list[list],
        mapping: dict,
        grid_params: dict,
    ):
        self.horizon = horizon
        self.nb_gens = nb_gens
        self.nb_storages = nb_storages
        self.ptdf = ptdf
        self.mapping = mapping
        self.nb_buses = ptdf.shape[1]
        self.grid_params = grid_params

        self._create_fluents()
        self._create_actions()

    def _create_fluents(self):
        # Creating problem 'variables' so called fluents in PDDL
        self.pgen = [
            [Fluent(f"pgen_{gen_id}_{t}", IntType) for t in range(self.horizon)]
            for gen_id in range(self.nb_gens)
        ]  # active power generated by generator i at time t

        self.soc = [
            [Fluent(f"soc_{storage_id}_{t}", RealType) for t in range(self.horizon)]
            for storage_id in range(self.nb_storages)
        ]  # state of charge of storage i at time t

        self.congestion = [
            [
                [
                    Fluent(f"congestion_{i}_{j}_{t}", BoolType)
                    for t in range(self.horizon)
                ]
                for j in range(self.nb_buses)
                if j != i
            ]
            for i in range(self.nb_buses)
        ]  # congestion between bus i and bus j at time t

        self.flow = [
            [
                [Fluent(f"flow_{i}_{j}_{t}", RealType) for t in range(self.horizon)]
                for j in range(self.nb_buses)
                if j != i
            ]
            for i in range(self.nb_buses)
        ]  # flow between bus i and bus j at time t

    def _create_actions(self):
        # Creating actions
        self.produce = [
            [
                InstantaneousAction(f"produce_{gen_id}_{t}", p=IntType)
                for t in range(self.horizon)
            ]
            for gen_id in range(self.nb_gens)
        ]  # action to produce p active power by generator i at time t

        self.charge = [
            [
                InstantaneousAction(f"charge_{storage_id}_{t}", s=IntType)
                for t in range(self.horizon)
            ]
            for storage_id in range(self.nb_storages)
        ]  # action to charge/discharge p active power by storage i at time t

        # add parameters, preconditions and effects to actions
        # for produce actions
        for gen_id in range(self.nb_gens):
            for t in range(self.horizon):
                p = self.produce[gen_id][t].parameter("p")
                self.produce[gen_id][t].add_precondition(
                    GE(
                        self.pgen[gen_id][t],
                        p - self.grid_params["gens"]["max_ramp_up"][gen_id],
                    )
                )
                self.produce[gen_id][t].add_precondition(
                    LE(
                        self.pgen[gen_id][t],
                        p + self.grid_params["gens"]["max_ramp_down"][gen_id],
                    )
                )
                self.produce[gen_id][t].add_effect(self.pgen[gen_id][t + 1], p)
                # implement the effect on the flow + congestion var

        for storage_id in range(self.nb_storages):
            for t in range(self.horizon):
                s = self.charge[storage_id][t].parameter("s")
                self.charge[storage_id][t].add_precondition(
                    GE(
                        self.soc[storage_id][t],
                        s - self.grid_params["storages"]["Emax"][storage_id],
                    )
                )
                self.charge[storage_id][t].add_precondition(
                    LE(
                        self.soc[storage_id][t],
                        s + self.grid_params["storages"]["Emin"][storage_id],
                    )
                )
                self.charge[storage_id][t].add_effect(self.soc[storage_id][t + 1], s)
                # implement the effect on the flow + congestion var

    def create_problem(self):
        problem = Problem("GridStability")
        problem.add_fluents(self.pgen)
        problem.add_fluents(self.soc)
        # TODO
